(* generated by Ott 0.10.17 ***locally nameless*** from: PLC.ott *)

Require Import Metatheory.

(** syntax *)
Definition termvar := var.

Inductive term : Set := 
 | term_var_b : nat -> term
 | term_var_f : termvar -> term
 | term_abs : term -> term
 | term_app : term -> term -> term.

(* EXPERIMENTAL *)

(** opening up abstractions *)
Fixpoint open_term_wrt_term_rec (k:nat) (e_5:term) (e__6:term) {struct e__6}: term :=
  match e__6 with
  | (term_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => term_var_b nat
        | inleft (right _) => e_5
        | inright _ => term_var_b (nat - 1)
      end
  | (term_var_f x) => term_var_f x
  | (term_abs e) => term_abs (open_term_wrt_term_rec (S k) e_5 e)
  | (term_app e1 e2) => term_app (open_term_wrt_term_rec k e_5 e1) (open_term_wrt_term_rec k e_5 e2)
end.

Definition open_term_wrt_term e_5 e__6 := open_term_wrt_term_rec 0 e__6 e_5.


(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_term *)
Inductive lc_term : term -> Prop :=    (* defn lc_term *)
 | lc_term_var_f : forall (x:termvar),
     (lc_term (term_var_f x))
 | lc_term_abs : forall (e:term),
      ( forall x , lc_term  ( open_term_wrt_term e (term_var_f x) )  )  ->
     (lc_term (term_abs e))
 | lc_term_app : forall (e1 e2:term),
     (lc_term e1) ->
     (lc_term e2) ->
     (lc_term (term_app e1 e2)).

(** free variables *)
Fixpoint fv_term (e_5:term) : vars :=
  match e_5 with
  | (term_var_b nat) => {}
  | (term_var_f x) => {{x}}
  | (term_abs e) => (fv_term e)
  | (term_app e1 e2) => (fv_term e1) \u (fv_term e2)
end.


(** substitutions *)
Fixpoint subst_term (e_5:term) (x5:termvar) (e__6:term) {struct e__6} : term :=
  match e__6 with
  | (term_var_b nat) => term_var_b nat
  | (term_var_f x) => (if eq_var x x5 then e_5 else (term_var_f x))
  | (term_abs e) => term_abs (subst_term e_5 x5 e)
  | (term_app e1 e2) => term_app (subst_term e_5 x5 e1) (subst_term e_5 x5 e2)
end.


(** definitions *)

(* defns Jval *)
Inductive pval : term -> Prop :=    (* defn pval *)
 | pval_var : forall (x:termvar),
     pval (term_var_f x)
 | pval_app : forall (e1 e2:term),
     pval e1 ->
     val e2 ->
     pval  ( (term_app e1 e2) ) 
with val : term -> Prop :=    (* defn val *)
 | val_pval : forall (e:term),
     pval e ->
     val e
 | val_abs : forall (L:vars) (e:term),
      ( forall x , x \notin  L  -> val  ( open_term_wrt_term e (term_var_f x) )  )  ->
     val  ( (term_abs e) ) .

(* defns Jred0 *)
Inductive red0 : term -> term -> Prop :=    (* defn red0 *)
 | red0_beta : forall (e1 e2:term),
     lc_term (term_abs e1) ->
     lc_term e2 ->
     red0 (term_app  ( (term_abs e1) )  e2)  (open_term_wrt_term  e1   e2 ) .

(* defns Jred1 *)
Inductive red1 : term -> term -> Prop :=    (* defn red1 *)
 | red1_empty : forall (e e':term),
     red0 e e' ->
     red1 e e'
 | red1_appL : forall (e1 e2 e1':term),
     lc_term e2 ->
     red1 e1 e1' ->
     red1 (term_app e1 e2) (term_app e1' e2)
 | red1_appR : forall (e1 e2 e2':term),
     lc_term e1 ->
     red1 e2 e2' ->
     red1 (term_app e1 e2) (term_app e1 e2')
 | red1_abs : forall (L:vars) (e e':term),
      ( forall x , x \notin  L  -> red1  ( open_term_wrt_term e (term_var_f x) )   ( open_term_wrt_term e' (term_var_f x) )  )  ->
     red1 (term_abs e) (term_abs e').

(* defns Jpara *)
Inductive para_red : term -> term -> Prop :=    (* defn para_red *)
 | para_red_var : forall (x:termvar),
     para_red (term_var_f x) (term_var_f x)
 | para_red_abs : forall (L:vars) (e e':term),
      ( forall x , x \notin  L  -> para_red  ( open_term_wrt_term e (term_var_f x) )   ( open_term_wrt_term e' (term_var_f x) )  )  ->
     para_red (term_abs e) (term_abs e')
 | para_red_app1 : forall (e1 e2 e1' e2':term),
     para_red e1 e1' ->
     para_red e2 e2' ->
     para_red (term_app e1 e2) (term_app e1' e2')
 | para_red_app2 : forall (L:vars) (e1 e2 e2' e1':term),
      ( forall x , x \notin  L  -> para_red  ( open_term_wrt_term e1 (term_var_f x) )  (open_term_wrt_term e1' (term_var_f x) ))  ->
     para_red e2 e2' ->
     para_red (term_app  ( (term_abs e1) )  e2)  (open_term_wrt_term  e1'   e2' ) .

(* defns Jcan *)
Inductive can : term -> term -> Prop :=    (* defn can *)
 | can_var : forall (x:termvar),
     can (term_var_f x) (term_var_f x)
 | can_abs : forall (L:vars) (e e':term),
      ( forall x , x \notin  L  -> can  ( open_term_wrt_term e (term_var_f x) )   ( open_term_wrt_term e' (term_var_f x) )  )  ->
     can (term_abs e) (term_abs e')
 | can_app1 : forall (e1 e2 e1' e2':term),
      (forall e', ( e1 ) <> term_abs e')  ->
     can e1 e1' ->
     can e2 e2' ->
     can (term_app e1 e2) (term_app e1' e2')
 | can_app2 : forall (L:vars) (e1 e2 e2' e1':term),
      ( forall x , x \notin  L  -> can  ( open_term_wrt_term e1 (term_var_f x) )  ( open_term_wrt_term e1' (term_var_f x) ))  ->
     can e2 e2' ->
     can (term_app  ( (term_abs e1) )  e2)  (open_term_wrt_term  e1'   e2' ) .

(** infrastructure *)

(* additional definitions *)


(* instanciation of tactics *)

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let D1 := gather_atoms_with (fun x => fv_term x) in
  constr:(A \u B \u D1).

Hint Constructors pval val red0 red1 para_red can lc_term.




