(* generated by Ott 0.10.16 ***locally nameless*** from: F.ott *)

Require Import Metatheory.

(** syntax *)
Definition termvar := var.
Definition typvar := var.

Inductive typ : Set := 
 | typ_var_b : nat -> typ
 | typ_var_f : typvar -> typ
 | typ_arrow : typ -> typ -> typ
 | typ_forall : typ -> typ.

Inductive term : Set := 
 | term_var_b : nat -> term
 | term_var_f : termvar -> term
 | term_abs : typ -> term -> term
 | term_app : term -> term -> term
 | term_gen : term -> term
 | term_inst : term -> typ -> term.

Definition typing_env : Set := list (atom * option typ).

(* EXPERIMENTAL *)

(** opening up abstractions *)
Fixpoint open_typ_wrt_typ_rec (k:nat) (t_5:typ) (t__6:typ) {struct t__6}: typ :=
  match t__6 with
  | (typ_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => typ_var_b nat
        | inleft (right _) => t_5
        | inright _ => typ_var_b (nat - 1)
      end
  | (typ_var_f a) => typ_var_f a
  | (typ_arrow t1 t2) => typ_arrow (open_typ_wrt_typ_rec k t_5 t1) (open_typ_wrt_typ_rec k t_5 t2)
  | (typ_forall t) => typ_forall (open_typ_wrt_typ_rec (S k) t_5 t)
end.

Fixpoint open_term_wrt_term_rec (k:nat) (e_5:term) (e__6:term) {struct e__6}: term :=
  match e__6 with
  | (term_var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => term_var_b nat
        | inleft (right _) => e_5
        | inright _ => term_var_b (nat - 1)
      end
  | (term_var_f x) => term_var_f x
  | (term_abs t e) => term_abs t (open_term_wrt_term_rec (S k) e_5 e)
  | (term_app e1 e2) => term_app (open_term_wrt_term_rec k e_5 e1) (open_term_wrt_term_rec k e_5 e2)
  | (term_gen e) => term_gen (open_term_wrt_term_rec k e_5 e)
  | (term_inst e t) => term_inst (open_term_wrt_term_rec k e_5 e) t
end.

Fixpoint open_term_wrt_typ_rec (k:nat) (t5:typ) (e_5:term) {struct e_5}: term :=
  match e_5 with
  | (term_var_b nat) => term_var_b nat
  | (term_var_f x) => term_var_f x
  | (term_abs t e) => term_abs (open_typ_wrt_typ_rec k t5 t) (open_term_wrt_typ_rec k t5 e)
  | (term_app e1 e2) => term_app (open_term_wrt_typ_rec k t5 e1) (open_term_wrt_typ_rec k t5 e2)
  | (term_gen e) => term_gen (open_term_wrt_typ_rec (S k) t5 e)
  | (term_inst e t) => term_inst (open_term_wrt_typ_rec k t5 e) (open_typ_wrt_typ_rec k t5 t)
end.

Definition open_typ_wrt_typ t_5 t__6 := open_typ_wrt_typ_rec 0 t__6 t_5.

Definition open_term_wrt_term e_5 e__6 := open_term_wrt_term_rec 0 e__6 e_5.

Definition open_term_wrt_typ t5 e_5 := open_term_wrt_typ_rec 0 e_5 t5.


(** terms are locally-closed pre-terms *)
(** definitions *)

(* defns LC_typ *)
Inductive lc_typ : typ -> Prop :=    (* defn lc_typ *)
 | lc_typ_var_f : forall (a:typvar),
     (lc_typ (typ_var_f a))
 | lc_typ_arrow : forall (t1 t2:typ),
     (lc_typ t1) ->
     (lc_typ t2) ->
     (lc_typ (typ_arrow t1 t2))
 | lc_typ_forall : forall (t:typ),
      ( forall a , lc_typ  ( open_typ_wrt_typ t (typ_var_f a) )  )  ->
     (lc_typ (typ_forall t)).

(* defns LC_term *)
Inductive lc_term : term -> Prop :=    (* defn lc_term *)
 | lc_term_var_f : forall (x:termvar),
     (lc_term (term_var_f x))
 | lc_term_abs : forall (t:typ) (e:term),
     (lc_typ t) ->
      ( forall x , lc_term  ( open_term_wrt_term e (term_var_f x) )  )  ->
     (lc_term (term_abs t e))
 | lc_term_app : forall (e1 e2:term),
     (lc_term e1) ->
     (lc_term e2) ->
     (lc_term (term_app e1 e2))
 | lc_term_gen : forall (e:term),
      ( forall a , lc_term  ( open_term_wrt_typ e (typ_var_f a) )  )  ->
     (lc_term (term_gen e))
 | lc_term_inst : forall (e:term) (t:typ),
     (lc_term e) ->
     (lc_typ t) ->
     (lc_term (term_inst e t)).

(** free variables *)
Fixpoint ftv_typ (t_5:typ) : vars :=
  match t_5 with
  | (typ_var_b nat) => {}
  | (typ_var_f a) => {{a}}
  | (typ_arrow t1 t2) => (ftv_typ t1) \u (ftv_typ t2)
  | (typ_forall t) => (ftv_typ t)
end.

Fixpoint fv_term (e_5:term) : vars :=
  match e_5 with
  | (term_var_b nat) => {}
  | (term_var_f x) => {{x}}
  | (term_abs t e) => (fv_term e)
  | (term_app e1 e2) => (fv_term e1) \u (fv_term e2)
  | (term_gen e) => (fv_term e)
  | (term_inst e t) => (fv_term e)
end.

Fixpoint ftv_term (e_5:term) : vars :=
  match e_5 with
  | (term_var_b nat) => {}
  | (term_var_f x) => {}
  | (term_abs t e) => (ftv_typ t) \u (ftv_term e)
  | (term_app e1 e2) => (ftv_term e1) \u (ftv_term e2)
  | (term_gen e) => (ftv_term e)
  | (term_inst e t) => (ftv_term e) \u (ftv_typ t)
end.


(** substitutions *)
Fixpoint tsubst_typ (t_5:typ) (a5:typvar) (t__6:typ) {struct t__6} : typ :=
  match t__6 with
  | (typ_var_b nat) => typ_var_b nat
  | (typ_var_f a) => (if eq_var a a5 then t_5 else (typ_var_f a))
  | (typ_arrow t1 t2) => typ_arrow (tsubst_typ t_5 a5 t1) (tsubst_typ t_5 a5 t2)
  | (typ_forall t) => typ_forall (tsubst_typ t_5 a5 t)
end.

Fixpoint subst_term (e_5:term) (x5:termvar) (e__6:term) {struct e__6} : term :=
  match e__6 with
  | (term_var_b nat) => term_var_b nat
  | (term_var_f x) => (if eq_var x x5 then e_5 else (term_var_f x))
  | (term_abs t e) => term_abs t (subst_term e_5 x5 e)
  | (term_app e1 e2) => term_app (subst_term e_5 x5 e1) (subst_term e_5 x5 e2)
  | (term_gen e) => term_gen (subst_term e_5 x5 e)
  | (term_inst e t) => term_inst (subst_term e_5 x5 e) t
end.

Fixpoint tsubst_term (t5:typ) (a5:typvar) (e_5:term) {struct e_5} : term :=
  match e_5 with
  | (term_var_b nat) => term_var_b nat
  | (term_var_f x) => term_var_f x
  | (term_abs t e) => term_abs (tsubst_typ t5 a5 t) (tsubst_term t5 a5 e)
  | (term_app e1 e2) => term_app (tsubst_term t5 a5 e1) (tsubst_term t5 a5 e2)
  | (term_gen e) => term_gen (tsubst_term t5 a5 e)
  | (term_inst e t) => term_inst (tsubst_term t5 a5 e) (tsubst_typ t5 a5 t)
end.


(** definitions *)

(* defns Jval *)
Inductive pval : term -> Prop :=    (* defn pval *)
 | pval_var : forall (x:termvar),
     pval (term_var_f x)
 | pval_app : forall (e1 e2:term),
     pval e1 ->
     val e2 ->
     pval  ( (term_app e1 e2) ) 
 | pval_inst : forall (e:term) (t:typ),
     lc_typ t ->
     pval e ->
     pval  ( (term_inst e t) ) 
with val : term -> Prop :=    (* defn val *)
 | val_pval : forall (e:term),
     pval e ->
     val e
 | val_abs : forall (L:vars) (t:typ) (e:term),
     lc_typ t ->
      ( forall x , x \notin  L  -> val  ( open_term_wrt_term e (term_var_f x) )  )  ->
     val  ( (term_abs t e) ) 
 | val_gen : forall (L:vars) (e:term),
      ( forall a , a \notin  L  -> val  ( open_term_wrt_typ e (typ_var_f a) )  )  ->
     val  ( (term_gen e) ) .

(* defns Jwf_env_typ *)
Inductive wfenv : typing_env -> Prop :=    (* defn wfenv *)
 | wfenv_empty : 
     wfenv  nil 
 | wfenv_cons_x : forall (G:typing_env) (x:termvar) (t:typ),
      x  `notin` dom  G  ->
     wftyp G t ->
     wfenv  ( x ~(Some  t ) ++  G ) 
 | wfenv_cons_a : forall (G:typing_env) (a:typvar),
      a  `notin` dom  G  ->
     wfenv G ->
     wfenv  ( a ~None ++  G ) 
with wftyp : typing_env -> typ -> Prop :=    (* defn wftyp *)
 | wftyp_var : forall (G:typing_env) (a:typvar),
      binds ( a ) None ( G )  ->
     wfenv G ->
     wftyp G (typ_var_f a)
 | wftyp_arrow : forall (G:typing_env) (t1 t2:typ),
     wftyp G t1 ->
     wftyp G t2 ->
     wftyp G (typ_arrow t1 t2)
 | wftyp_forall : forall (L:vars) (G:typing_env) (t:typ),
      ( forall a , a \notin  L  -> wftyp  ( a ~None ++  G )   ( open_typ_wrt_typ t (typ_var_f a) )  )  ->
     wftyp G (typ_forall t).

(* defns Jwfterm *)
Inductive wfterm : typing_env -> term -> typ -> Prop :=    (* defn wfterm *)
 | wfterm_val : forall (G:typing_env) (x:termvar) (t:typ),
     wfenv G ->
      binds ( x ) (Some ( t )) ( G )  ->
     wfterm G (term_var_f x) t
 | wfterm_app : forall (G:typing_env) (e1 e2:term) (t1 t2:typ),
     wfterm G e1 (typ_arrow t2 t1) ->
     wfterm G e2 t2 ->
     wfterm G (term_app e1 e2) t1
 | wfterm_abs : forall (L:vars) (G:typing_env) (t1:typ) (e:term) (t2:typ),
      ( forall x , x \notin  L  -> wfterm  ( x ~(Some  t1 ) ++  G )   ( open_term_wrt_term e (term_var_f x) )  t2 )  ->
     wfterm G (term_abs t1 e) (typ_arrow t1 t2)
 | wfterm_inst : forall (G:typing_env) (e:term) (t t':typ),
     wftyp G t ->
     wfterm G e (typ_forall t') ->
     wfterm G (term_inst e t)  (open_typ_wrt_typ  t'   t ) 
 | wfterm_gen : forall (L:vars) (G:typing_env) (e:term) (t:typ),
      ( forall a , a \notin  L  -> wfterm  ( a ~None ++  G )   ( open_term_wrt_typ e (typ_var_f a) )   ( open_typ_wrt_typ t (typ_var_f a) )  )  ->
     wfterm G (term_gen e) (typ_forall t).

(* defns Jred0 *)
Inductive red0 : term -> term -> Prop :=    (* defn red0 *)
 | red0_beta : forall (t:typ) (e1 e2:term),
     lc_typ t ->
     lc_term (term_abs t e1) ->
     lc_term e2 ->
     red0 (term_app  ( (term_abs t e1) )  e2)  (open_term_wrt_term  e1   e2 ) 
 | red0_beta_t : forall (e:term) (t:typ),
     lc_term (term_gen e) ->
     lc_typ t ->
     red0 (term_inst  ( (term_gen e) )  t)  (open_term_wrt_typ   e    t ) .

(* defns Jred1 *)
Inductive red1 : term -> term -> Prop :=    (* defn red1 *)
 | red1_empty : forall (e e':term),
     red0 e e' ->
     red1 e e'
 | red1_appL : forall (e1 e2 e1':term),
     lc_term e2 ->
     red1 e1 e1' ->
     red1 (term_app e1 e2) (term_app e1' e2)
 | red1_appR : forall (e1 e2 e2':term),
     lc_term e1 ->
     red1 e2 e2' ->
     red1 (term_app e1 e2) (term_app e1 e2')
 | red1_abs : forall (L:vars) (t:typ) (e e':term),
     lc_typ t ->
      ( forall x , x \notin  L  -> red1  ( open_term_wrt_term e (term_var_f x) )   ( open_term_wrt_term e' (term_var_f x) )  )  ->
     red1 (term_abs t e) (term_abs t e')
 | red1_inst : forall (e:term) (t:typ) (e':term),
     lc_typ t ->
     red1 e e' ->
     red1 (term_inst e t) (term_inst e' t)
 | red1_gen : forall (L:vars) (e e':term),
      ( forall a , a \notin  L  -> red1  ( open_term_wrt_typ e (typ_var_f a) )   ( open_term_wrt_typ e' (typ_var_f a) )  )  ->
     red1 (term_gen e) (term_gen e').

(** infrastructure *)

(* additional definitions *)


(* instanciation of tactics *)

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let D1 := gather_atoms_with (fun x => fv_term x) in
  let D2 := gather_atoms_with (fun x => ftv_typ x) in
  let D3 := gather_atoms_with (fun x => ftv_term x) in
  constr:(A \u B \u D1 \u D2 \u D3).

Hint Constructors pval val wfenv wftyp wfterm red0 red1 lc_typ lc_term.




